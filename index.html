<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comandos y uso Git</title>
    <link rel="stylesheet" href="css/estilos.css">
    <link rel="stylesheet" href="https://afeld.github.io/emoji-css/emoji.css">
</head>
<header>
    <img src="./img/logo_de_git.png">
    <span>Comandos de GitHub</span>
    <i class="em em-rocket" aria-role="presentation" aria-label="ROCKET"></i>
</header>
<body>
    <h6 class="fixed" id="changeWeb"><span>Cambiar a versi&oacute;n nocturna</span></h6>
    <h1>Comandos m&aacute;s usados:</h1>
    <ul>
        <li><b>git init:</b> se usa para iniciar un nuevo repositorio de Git</li>
        <li><b>git config --global user.name "Nombre":</b> Configura nombre usuario</li>
        <li><b>git config --global user.email "email":</b> Configura email usuario</li>
        <li><b>git status: </b>Muestra el estado de actual de los archivos ubicados en el &aacute;rea de staging</li>
        <li><b>git add nombreArhivo.extension: </b>Agrega al &aacute;rea de staging el o los archivos.</li>
        <li><b>git commit -m "Descripcion commit": </b>Agrega los cambios a la BD del repositorio de git</li>
        <li><b>git commit -am "Descripci&oacute;n commit": </b>Nos ahorra el tener que utilizar <b>git commit .</b>, este comando solo es v&aacute;lido para archivos que ya existen en el repositorio, no afectar&aacute; a archivos nuevos que no hayan sido agregados con add</li>
        <li><b>git commit:</b> Abrir&aacute; el editor Vim para poder agregar un comentario, siempre es obligatorio agregar un comentario para el commit. Para poder editar el comit usar "ESC  i". Para guardar cambios ESC + SHIFT + Z Z</li>
        <li><b>git log: </b>Muestra el historial detallado con commit e id, de todos los commits en dicho repositorio</li>
        <li><b>Git log repotenciado:</b> Para tener una visualizaci&oacute;n m&aacute;s gr&aacute;fica de tu historial en un repositorio, puedes usar el comando <b>git log --all -decorate- oneline</b> con esto, podr&aacute;s ver el historial de cambios y ramas de forma m&aacute;s gr&aacute;fica. <br><img src="img/git_log_all_graph_decorate.png" alt="ver log de commits y ramas historicas en un repositorio"><br></li>
        <li><b>git log para buscar</b> si deseas buscar palabras que hayas dejado en tus commits, puedes usar <b>git log -S palabra</b>, esto te retornar&aacute; todos los commits que incluyan la palabra a buscar.</li>
        <li><b>git diff: </b>Permite ver las diferencias entre el staging y nuestro archivo en local. tiene las variaciones <b>git diff id1 id2</b> donde se comparan dos versiones seg&uacute;n los id del commit seleccionado. y <b>git diff --stat</b> donde ves las diferencias m&aacute;s resumidas.</li>
        <li><b>git show: </b>Se utiliza para ver el commit y la rama en el que te encuentras actualmente.</li>
        <br>
        <li><b>git grep:</b> se usa para buscar texto en nuestros archivos del repositorio, puedes ver la cantidad de veces que se usa una palabra, incluso incluir expresiones regulares. Un ejemplo ser&iacute;a usar <b>git gre -n palabra</b> para ver en que archivos y que l&iacute;neas esta la palabra "palabra" o <b>git grep -c palabra</b> para ver la cantidad de veces que se repite la palabra "palabra"</li>
    </ul>

    <h1>Comando de consola &uacute;tiles</h1>
    <p>Esta secci&oacute;n es un extra, no tiene que ver directamente con Git, pero puede apoyar de una u otra manera tu repositorios.</p>
    <ul>
        <li><b>Crear un alias:</b> para resumir comandos que sean muy extensos, se puede utilizar el comando <b>alias nombreNuevoComando="Comando a convertir"</b> de esta manera, podemos usar una palabra m&aacute;s f&aacute;cil de recordar para nosotros. <br><b>Ejemplo:</b> alias arbolito="git log --all --graph --decorate --oneline"</li>
    </ul>

    <h1>Comandos importantes:</h1>
    <p>Estos comandos se separan ya que tienen funciones muy importantes.</p>
    <ul>
        <li><b>git reset idCommit --hard/soft</b> Este comando se encarga de regresar a una versi&oacute;n especificada. Se debe tener cuidado con este comando, ya que borrar&aacute; absolutamente todos los cambios realizados despues de dicho commit. existen dos variastes para el mismo. <b>--hard</b> har&aacute; que regrese por completo todo a la versi&oacute;n elegida, perdiendo incluso, los cambios en staging. <b>--soft</b> cumple el mismo rol, pero mantiene los cambios en staging para su posterior commit. </li>
        <li><b>git reset HEAD (Me encanta XD): </b>Regresa todos los cambios en staging como unstaged. Es decir, revierte el git add.</li>
        <li><b>git checkout idCommit archivo.extension:</b> Obtiene la versi&oacute;n especificada de dicho archivo. PERO, no elimina sus versiones posteriores. La versi&oacute;n obtenida se tomar&aacute; como untracked y podr&aacute; ser agregada al staging para realizar commit y crear una nueva versi&oacute;n.</li>
        <li><b>git rm --cached:</b> Elimina los archivos del &aacute;rea de Staging y del pr&oacute;ximo commit pero los mantiene en nuestro disco duro.</li>
        <li><b>git rm --force:</b> Elimina los archivos del &aacute;rea de Staging y de nuestro disco duro.</li>
        <ul>Para visualizar todo el historial de git, aunque lo hayamos eliminado, usamos el comando <b>git reflog</b> con este, podemos ver las referencias de los commit e ir y venir entre las distintas versiones con git RESET</ul>
        <ul><b>Recordatorio:</b> Â¡GIT RESET es una mala pr&aacute;ctica! Solo usarlo en casos de extrema emergencia y como &uacute;ltima opci&oacute;n.</ul>
    </ul>
    <br>

    <h1>Comandos en ramas</h1>
    <p>Estos son los comandos aplicados para manejarse entre ramas, crear nuevas ramas, etc.</p>
    <ul>
        <li><b>git branch nameBranch:</b> Se utiliza para crear una nueva rama.</li>
        <li><b>git checkout nameBranch</b> Se utiliza para dirigirse hacia la rama elegida.</li>
        <li><b>git branch -D nombreRama</b> se utiliza para eliminar ramas en git.</li>
        <li><b>git branch -r</b>: Permite ver las ramas remotas.</li>
        <li><b>git branch -a</b>: Permite ver todas las ramas incluyendo ramas locales y ramas locales.</li>
        <li><b>git push origin nombreRama</b> se utiliza para enviar a un repositorio remoto la rama que hemos creado</li>
        <li><b>git merge nombreRama: </b> Este comando es <b>s&uacute;per importante</b>, se utiliza cuando quieres unir los cambios entre 2 ramas. <br> Cuando tienes los cambios de una nueva que creaste y ya les hiciste commit, puedes hacer un merge para fusionarlos con tu rama de master. El proceso puede ser MASTER -> RAMA_NUEVA o RAMA_NUEVA -> MASTER. Cuando quieres dejar todo en master para tener todo en la rama principal, debe usar la segunda opci&oacute;n.</li><br>
        <ul>
            <li><b>Conflictos: </b>En GIT, los conflictos aparecen cuando existen diferencias en las mismas l&iacute;neas de c&oacute;digo de los archivos. Ya sea que un compaÃ±ero modifico la misma l&iacute;nea de un archivo CSS que t&uacute; y tienen diferentes cosas. 
            <br> Los conflictos son f&aacute;ciles de solucionar y no debe generarte caos ni confusi&oacute;n. La consola de GIT te indicar&aacute; el estatus del merge que intentaste realizar. <br> <b>Auto-merging archivo.extension</b> indicar&aacute; un merge correcto y <b>CONFLICT (Content) archivo.extension</b> indicar&aacute; un conflicto.
            <br><br>
            <img src="img/screenshot_error_merge.png" alt="error de consola al realizar merge" />
            <br><br>
            Al revisar nuestro archivo en conflicto, encontraremos algo muy peculiar en el, GIT nos muestra exactamente cual fue la l&iacute;nea en conflictos y cuales son las diferencias entre nuestra rama actual y la que queremos obtener. As&iacute; se debe ver al usar el bloc de notas:
            <br><br>
            <img src="img/screenshot_error_merge_blocNotas.png" alt="diferencias de c&oacute;digo bloc de notas" />
            <br><br>
            Debemos elegir entre el c&oacute;digo que deseamos dejar en el repositorio y para esto, debemos comunicarnos con la persona que escribi&oacute; el c&oacute;digo (si es que estamos trabajando colaborativamente con alguien m&aacute;s) para decidir que c&oacute;digo debe irse a la versi&oacute;n del merge. Posterior a este paso, se deben comentar la l&iacute;nea de <b>"<<<<"</b>, las de <b>"===="</b>  y las de <b>">>>>"</b>  junto con el c&oacute;digo que no ir&aacute; al repositorio.
            <br>
            Se deben guardar los cambios en el archivo y realizar un nuevo <b>git add .</b> adem&aacute;s de un <b>git commit -m "Comentario relacionado con la soluci&oacute;n del conflicto en el merge"</b>
            <br><br>
            <b>Adicional:</b> Si usas VSCode, podr&aacute;s ver que el te da una sugerencia de que hacer con los cambios:
            <br><br>
            <img src="img/screenshot_error_merge_code.png" alt="diferencias de c&oacute;digo VSCode" />
            <br><br>
            Si eliges <b>Accept Current Change</b> estar&aacute;s dejando los cambios de la rama actual, en cambio, si elgies <b>Accept Incoming Change</b> estar&aacute;s obteniendo los cambios de la rama desde la cual est&aacute;s obteniendo los cambios.
            </li>
            <li><b>Publicar ramas en repositorio remotos:</b> Si deseas que tu rama pueda ser usada/visualizada  por otros desarrolladores en un repositorio remoto, debes usar el comando <b>git push origin nombreRama</b></li>
        </ul>
    </ul>
    <br>

    <h1>Repositorios remotos - GitHub</h1>
    <p>Conoceremos como poder conectar nuestro repositorio local con alg&uacute;n repositorio remoto, subir nuestros cambios a dicho repositorio, obtener los cambios desde el repositorio y mucho m&aacute;s.</p>
    <p>Para este caso de prueba utilizaremos el repositorio remoto m&aacute;s conocido del mundo, <a href="https://github.com/">GitHub</a>.</p>
    <ol>
        <li>Primero, debemos crearnos una cuenta en GitHub y crear un nuevo repositorio. Preferiblemente, debemos crear el archivo README ya que a trav&eacute;s de el podremos indicarle a otros desarrolladores de que va nuestro c&oacute;digo.</li><br>
        <li>Luego de crear el repositorio, Github nos dar&aacute; la url del mismo, esta la utilizaremos para agregar este origen remoto desde nuestro repositorio local. Se debe copiar la ruta HTTPS que github nos di&oacute;: <br><br> <img src="img/url_repo_github.png" alt="url de nuestro repositorio remoto"><br><br></li>
        <li>Usar el comando <b>git remote add origin urlRepositorioRemoto</b> con esto, estaremos agregando la referencia del repositorio remoto a nuestro repositorio en local. Posterior a esto, la consola de git no arrojar&aacute; ning&uacute;n mensaje, pero si usamos el comando <b>git remove -v</b> podremos visualizar el repositorio remoto al que hacemos referencia actualmente. 
        <br><br>
        <img src="img/git_remote_v.png" alt="git remote -v para ver la referencia del repositorio remoto">
        <br><br>
        Te dejo la url de este mismo repositorio para que puedas probar: <b>https://github.com/avasquez-ve/gitCommands.git</b></li><br>
        <li>Como ya tenemos la referencia del repositorio remoto, ahora debemos obtener la historia que se encuentre en dicho repositorio, esta acci&oacute;n se debe realizar siempre antes de enviar los cambios desde el repositorio local. <br><br> Si el repositorio remoto es diferente a nuestro repositorio local, es probable que Git nos de un warning con el mensaje <b>"refusing to merge unrelated histories"</b> esto quiere decir que no puede hacer la fusi&oacute;n debido a que las historias de los dos repositorios son diferentes. Para forzar esta acci&oacute;n y poder obtener la historia del repositorio remoto debemos usar el comando <b>git pull origin master --allow-unrelated-histories</b> para permitir unir ambas historias.</li>
        <br><br>
        <img src="img/git_pull_origin_master.png" alt="git pull origin master, mensajes de advertencia">
        <br><br>

        <li>Con el comando <b>ls -al</b> podremos ver el archivo <b>README</b> creado desde GitHub. Y al ejecutar <b>git log</b> tambi&eacute;n veremos el commit hecho en GitHub para dicho archivo. 
        <br><br>
        <img src="img/ls-al.png" alt="comando ls -al. Usado para visualizar en forma de lista los archivos visibles y ocultos de un directorio">
        <br><br>
        </li>
        <li>Ahora, para subir los cambios locales al repositorio, debemos usar el comando <b>git push origin master</b>, con esto, ya nuestros cambios locales estar&aacute;n dentro del repositorio remoto. Recordar siempre que este comando lo debemos ejecutar desde la <b>rama master</b> para no generar conflictos.</li>
        <br><br>
        <img src="img/git_push_origin_master.png" alt="comando git push origin master. Usado para subir los cambios hacia un repositorio remoto">
        <br><br>
        <p>As&iacute; quedo nuestro repositorio remoto en GitHub luego de agregar los cambios desde el repositorio local</p>
        <br>
        <img src="img/proyectoGitHub.png" alt="repositorio en GitHub">
        <br>
    </ol>

    <h1>Configurar tus llaves SSH en local</h1>
    <p>Aprenderemos como usar las llaves SSH para conectarnos a GitHub usando SSH y dejar a un lado HTTPS</p>
    <p>Para hacer nuestra conexi&oacute;n a&uacute;n m&aacute;s segura, podemos usar llaves encriptadas, con las cuales enviamos nuestros datos cifrados. Dichos datos solo podr&aacute;n ser decifrados con una llave p&uacute;blica que compartiremos con GitHub.</p>
    <ol>
        <li><b>Primer paso:</b> Generar las llaves SSH con el comando <br> <b>ssh-keygen -t rsa -b 4096 -C "tu@email.com"</b> <br> debemos usar el mismo email que usamos para Github. Tomar en cuenta que luego de apretar enter, nos va a sugerir agregarle una contraseÃ±a a dicha llave para hacerla a&uacute;n m&aacute;s segura. Este paso es opcional, si no queremos agregarle una contraseÃ±a solo aprietas ENTER.</li><br>
        <li><b>Las llaves se guardaran</b> en una carpeta oculta llamada .ssh donde tendremos la llave p&uacute;blica <b>id_rsa.pub</b> y la privada <b>id_rsa</b> NOTA: La llave privada <b>jam&aacute;s</b> se debe compartir con nadie ni con ning&uacute;n otro dispositivo.</li><br>
        <li><b>Segundo paso:</b> para terminar de configurar las claves, debemos comprobar que el servidor se encuentre activo, para esto usar el comando <br> <b>eval $(ssh-agent -s)</b> <br> lo cual nos deber&iacute;a retornar un mensaje <b>Agent pid numeroAleatorio</b></li><br>
        <li><b>Tercer y &uacute;ltimo paso:</b> ahora, solo debemos agregar al servidor nuestra llave privada, para esto, usar el comando <br> <b>ssh-add ruta-donde-guardaste-tu-llave-privada</b> <br> Y listo, ya tendremos configurada nuestra llave privada para poder conectarnos a trav&eacute;s de SSH con GitHub</li><br>
    </ol>

    <h1>Conectarnos a Github a trav&eacute;s de SSH</h1>
    <p>Luego de haber creado y configurado nuestra llave privada. Debemos configurar nuestra llave p&uacute;blica (la &uacute;nica que podemos compartir) con Github. Es importante tener en cuenta que debemos realizar los pasos anteriores, de lo contrario, no podremos continuar con este paso.</p>
    <ol>
        <li><B>Como primer paso:</B> debemos agregar nuestra llave p&uacute;blica a nuestra cuenta de Github. Para eso debemos copiar el contenido de nuestra llave publica, ubicada en el archivo <b>id_rsa.pub</b></li><br>
        <li><b>El segundo paso es:</b> Ingresar en nuestra cuenta de Github y dirigirnos a la configuraci&oacute;n y posteriormente a la gestion de KEYS SSH <br> url: <a href="https://github.com/settings/keys">https://github.com/settings/keys</a><br> Debemos hacer click en  <b>New SSH Key</b> <br> <img src="img/crear_nueva_key_ssh.png" alt="boton crear nueva key ssh"><br> y luego agregar como t&iacute;tulo, el pc que tendr&aacute; asignado dicha key publica, esto es para poder identificarlo, ya que podemos tener varios equipos conectados por SSH a nuestros repositorios. Al finalizar, hacer click en <b>Add SSH KEY</b><br><img src="img/agregando_key.png" alt="agregando key ssh"><br> </li><br>
        <li>Ahora podremos ver que nuestra key SSH se agreg&oacute; correctamente <br><img src="img/identificador_ssh_key.png" alt="ver key agregada"><br></li><br>

        <li><b>Como siguiente paso</b>, debemos configurar nuestro repositorio local para dejar de usar HTTPS y empezar a usar SSH con nuestras nuevas keys. Para esto, debemos ir a nuestro repositorio y ejecutar el comando <br> <b>git remote set-url origin url-ssh-del-repositorio-en-github</b> <br> Con esto estaremos cambiando la url del repositorio en github. Podemos comprobar la nueva url usando <b>git remove -v</b></li><b></b>
        <li>Ahora puedes hacer un <b>git pull origin master</b> confirmar los mensajes, realizar cambios en tu repositorio local y hacer un <b>git push origin master</b></li>
    </ol>

    <h1>Tags y versiones en Git y GitHub</h1>
    <p>Los tags nos permiten asignar versiones a los commits con cambios m&aacute;s importantes o significativos en nuestro proyecto. A continuaci&oacute;n, se presentan los comandos para trabajar con las etiquetas:</p>
    <ul>
        <li><b>Crear un tag: </b> antes de crear un tag se debe elegir el commit el cual queremos identificar, para esto, podemos hacer un: <br><br><b>git log --all --graph --decorate --oneline</b> o un <b>git log --all --oneline</b> y copiar el id del commit. <br><br> Se usan los comandos anteriores para poder obtener el id m&aacute;s corto. <br> Luego, ejecutamos el comando para crear el tag <b>git tag -a nombreDelTag -m "Comentario asociado al tag" idDelCommit</b></li><br>
        <li><b>Visualizar tags creados:</b> Para visualizar los tags que tenemos creados podemos usar los comandos <b>git tag</b> o <b>git show-ref --tags</b> con el primero, solo veremos el nombre del tag y con el segundo, podremos ver el commit generado al crear el tag y la ubicacion.</li><br>
        <li><b>Enviar tags a un repositorio remoto: </b>Para publicar nuestros tags se debe usar el comando <b>git push origin --tags</b> si te das cuenta, se hace diferente a publicar un commit com&uacute;n.</li>
        <li><b>Eliminar tags:</b> Los tags son publicados en Github como releases, versiones estables de nuestro c&oacute;digo que deber&iacute;an funcionar sin problemas. Si llegas a publicar un tag por equivocaci&oacute;n, puedes borrarlo con los siguientes dos comandos: <br><br> <b>git tag -d nombreDelTag</b> con esto estaremos borrando el tag en el repositorio local. Para eliminarlo del repositorio remoto se debe usar <b>git push origin :refs/tags/nombreDelTag</b></li>
    </ul>

    <h1>Usando Rebase</h1>
    <p>Rebase se utiliza para unir los cambios que tengamos en una rama con nuestra rama master y no dejar rastros de la existencia de dicha rama creada.</p>
    <p>El rebase es &uacute;til, por ejemplo, si estamos realizando arreglos de un bug y no se desean mostrar estos cambios como tomados de una rama, si no como parte del flujo normal de la aplicaci&oacute;n.</p>
    <p>Rebase se encarga de ajustar los cambios al momento en que se realizaron y hacer un merge desde el primer commit, no desde el &uacute;ltimo (como funciona normalmente un flujo en git)</p>
    <ul>
        <li>Para hacer un rebase, primero debemos crear una nueva rama, posicionarnos en dicha rama con <b>git checkout</b> y realizar los cambios.</li>
        <li>Luego de tener nuestros cambios, debemos ejecutar el comando <b>git rebase master</b> desde nuestra rama de cambios <b>es importante que git rebase se haga desde la rama con los cambios primero</b></li>
        <li>Con esto, ya tendremos unidas las historias de master con nuestra nueva rama. Posteior a esto se debe realizar checkout a mastery ejecutar el rebase desde master apuntando a nuestra rama de cambios <b>git rebase nombreRamaCambios</b></li>
        <li>Esto lo que har&aacute; es integrar master con nuestra rama de cambios y luego pasarla a master nuevamente con todos los cambios incluidos, como un merge.</li>
        <li><b>Nota: </b>Usar rebase es una mala pr&aacute;ctica, ya que no tenemos historia de lo que sucede, no se sabe quien hizo que cambios y en ocasiones, si master avanz&oacute; mucho, se pueden generar muchos conflictos.</li>
    </ul>

    <h1>Usando Git Stash</h1>
    <p>Git stash es muy &uacute;til cuando tienes cambios que no deseas realizarle commits a&uacute;n, o para realizar pruebas, experimentos que no requieran o no quieras crear una rama para poder visualizarlos</p>
    <p>El stash es una forma de almacenar tus cambios pendientes para luego poder obtenerlos y hacerles commit, incluso puedes crear una rama con esos cambios pendientes, hacerle commit en la nueva rama y luego realizar un merge en master.</p>
    <p>Pasos para usar Stash</p>
    <ul>
        <li>Primero, puedes realizar cualquier cambio en un documento y guardar los cambios.</li>
        <li>Luego, usar el comando <b>git stash</b>, esto guardar&aacute; tus cambios pendientes en un listado de WIP (Work in Process).</li>
        <li>El listado lo puedes consultar usando <b>git stash list</b></li>
        <li>Para obtener los cambios pendientes, debes usar el comando <b>git stash pop</b> Â¡OJO! esto lo debes realizar en la misma rama que estabas creando los cambios, ya que si haces pop en una rama diferente, puedes generar un conflicto.</li>
        <li>Una alternativa para guardar tus cambios pendientes y visualizarlos sin tocar la rama master, es usa el comando <b>git stash branch nombreRama</b> esto crear&aacute; autom&aacute;ticamente una nueva rama con los cambios que estaban en el stash</li>
        <li><b>Eliminar un stash</b> si deseas eliminar un stash, puedes usar el comando <b>git stash drop</b> esto eliminar&aacute; el stash que tengas y dejar&aacute; la versi&oacute;n original.</li>
    </ul>

    <h1>Git Clean</h1>
    <p>Este comando es utilizado para eliminar archivos que no forman parte de nuestro directorio de trabajo, archivos como .logs, resultados de una compilaci&oacute;n, etc.</p>
    <ul>
        <li>Para eliminar dichos archivos podemos probar creando copias de archivos existentes en nuestro repositorio</li>
        <li>Luego, ejecutar <b>git clean --dry-run</b> esto se usa para verificar que eliminar&aacute; git clean</li>
        <li>Al confirmar lo que borrar&aacute;, ejecutamos <b>git clean -f</b> con esto, ya estaremos borrando dichos archivos</li>
        <li><b>Nota:</b> Git no eliminar&aacute; los archivos que se encuentren dentro del .gitignore, tampoco eliminar&aacute; los archivos que tengan el mismo nombre, asi esten en directorios distintos.</li>
    </ul>

    <h1>Git cherry pick</h1>
    <p>Existe un mundo alternativo en el cual vamos avanzando en una rama pero necesitamos en master uno de esos avances de la rama, para eso utilizamos el comando git cherry-pick IDCommit.</p>
    <p>cherry-pick es una mala pr&aacute;ctica porque significa que estamos reconstruyendo la historia.</p>
    <ul>
        <li>Para usar cherry pick, debes ejecutar el comando git cherry-pick IDCommit desde la rama donde deseas traer los cambios de dicho commit.</li>
        <li>Es posible que genere conflictos este comando, as&iacute; que debes tenerlo en cuenta para poder hacer el cherry pick.</li>
    </ul>

    <h1>Git amend</h1>
    <p>A veces hacemos un commit, pero resulta que no quer&iacute;amos mandarlo porque faltaba algo m&aacute;s.</p>
    <p>Amend remienda nuestro error y los cambios que hicimos nos los permite agregar al commit m&aacute;s reciente.</p>
    <ul>
        <li>Para esto, se debe hacer los cambios necesario, <b>hacer un git add</b> y posterior a esto, ejecutar el comando <b>git commit --amend</b></li>
    </ul>

    <h1>Git shortlog</h1>
    <p>Cuando necesitamos hacer un trabajo donde colaboramos con diferentes programadores es bueno saber los que hace cada uno de ellos para esto usamos <b>git shortlog -n</b></p>
    <p>El cual nos mostrar&aacute; algo como lo siguiente: </p>
    <ul class="image-list">
        <li>
            <br>
            <img src="./img/git_shortlog.jpg" alt="">
            <br>
        </li>
    </ul>
    
    <p>Las contribuciones de cada usuario del proyecto aparecer&aacute;n en pantalla.</p>
    <p>Pero podemos ver variantes del mismo comando:</p>
    <ul>
        <li><b>git shortlog -sn</b>: El cual nos muestra el numero de aportes de cada usuario.</li>
        <li><b>git shortlog -sn --all</b>: El cual nos muestra todas las contribuciones de cada usuario adem&aacute;s incluyendo los commits borrados</li>
        <li><b>git shortlog -sn --all --no-merges</b>: El cual nos muestra todas las contribuciones de cada usuario pero no los merges</li>
    </ul>

    <h1>Alias de git</h1>
    <p>As&iacute; como podemos aÃ±adir alias en nuestra computadora tambi&eacute;n puedes hacer alias en la configuraci&oacute;n de git con el siguiente comando : </p>
    <p><b>git config --global alias.nombre_del_alias "comando a ejecutar"</b></p>
    <p>Se ejecuta el alias con el siguiente comando: <b>git nombre_del_alias</b> </p>
    <ul class="image-list">
        <li>
            <br>
            <img src="./img/git_alias.png" alt="imagen de alias de git">
            <br>
        </li>
    </ul>
    
    <h1>Git blame</h1>
    <p>Permite ver l&iacute;nea por l&iacute;nea quien ha sido el creador de las mismas, para eso tenemos que escribir el siguiente comando : <b>git blame archivo.extension</b></p>
    <ul class="image-list">
        <li>
            <br>
            <img src="./img/git_blame.png" alt="imagen de blame en git">
            <br>
        </li>
    </ul>
    <p>Este comando tambi&eacute;n permite variaciones: </p>
    <ul>
        <li><b>git blame archivo.extension -L35,53</b>: Permite ver las el contenido entre las l&iacute;neas 35 y 53 del archivo.</li>
        <li><b>git blame archivo.extension -L35,53 -c</b>: Permite ver lo mismo que el anterior comando pero con un poco m&aacute;s de formato.</li>
    </ul>

    <h1>Magia para desarolladores</h1>
    <p>Si has llegado hasta aqu&iacute; y ya manejas de memoria los principales comandos de git, los comandos para las ramas,sabes hacer un merge sin caer en la locura y trabajar con repositorios remotos.</p>
    <p>Te dejo un buen comando de git que te ayudar&aacute; a ver f&aacute;cilmente tu historial de commits.</p>
    <p><b>Â¡OJO!</b> has click en el siguiente enlace solo si REALMENTE manejas y comprendes los comandos anteriores y el flujo de Git, de lo contrario, <b>REGRESA OTRO D&iacute;A</b> ðŸ‘º</p>
    <p id="showCommand"><b>Visualizar el comando</b></p>
    <ul id="contH">
    </ul>
    
    <script>
        document.addEventListener("DOMContentLoaded", function (e) {
            var date = new Date();
            var hours = date.getHours();
            if (hours >= 20 || hours <= 7) {
                setTimeout(function() {
                    if (confirm("Al parecer ya se hizo de noche, Â¿deseas activar el modo nocturno?")) {
                        document.body.style.backgroundColor = '#2d2d2d';
                        document.body.style.color = '#FFFFFF';
                        btnVision.innerText = "Cambiar a versi&oacute;n normal";
                    }
                },4000);
            }
        });

        var btnVision = document.getElementById("changeWeb");
        btnVision.addEventListener("click", function (e) {
            var txtBtnVision = btnVision.innerText;

            if (txtBtnVision == "Cambiar a versi&oacute;n nocturna") {
                document.body.style.backgroundColor = '#282A35';
                document.body.style.color = '#FFFFFF';
                btnVision.innerText = "Cambiar a versi&oacute;n normal";
            } else {
                document.body.style.backgroundColor = '#FFFFFF';
                document.body.style.color = '#000000';
                btnVision.innerText = "Cambiar a versi&oacute;n nocturna";
            }
        });

        var txtShowCommand = document.getElementById("showCommand");
        var ulHidden = document.getElementById("contH");
        var dataSinBd = [
            {
                "hiddenContent" : [
                    {
                        "comandosMagicos": [
                            {//Si llegaste hasta aqu&iacute; y no cumples con los requisitos mencionados en la web, VETE DE AQU&iacute; XD.
                                "descripcion" : "<span>Ver un git log en interfaz sin descargar un programa extra</b>: Git permite ver de forma gr&aacute;fica en una interfaz los commits que has hecho, el historial de ramas e incluso los tags. Usa el comando <b>gitk</b> y ver&aacute;s algo parecido a esto.</span>",
                                "img" : [
                                    {"src":"img/revisemos-faz.png", "alt": "revisa el comando gitk"}
                                ]
                            }//Si llegaste hasta aqu&iacute; y no cumples con los requisitos mencionados en la web, VETE DE AQU&iacute; XD.
                        ]
                    }
                ]
            }
        ]

        txtShowCommand.addEventListener("click", function (e) {
            if (confirm("Es en serio, solo continua si estas preparado")) {
                if (ulHidden.children.length > 0) {
                    return false;
                }
                else
                {
                    var newLi = document.createElement("li");
                    var newImg = document.createElement("img");
                    var htmlBr = document.createElement("br");
                    var descripcion = dataSinBd[0].hiddenContent[0].comandosMagicos[0].descripcion;
                    var srcImg = dataSinBd[0].hiddenContent[0].comandosMagicos[0].img[0].src;
                    var altImg = dataSinBd[0].hiddenContent[0].comandosMagicos[0].img[0].alt;
    
                    //asignaciones
                    ulHidden.append(newLi);
                    if (methodValidator(newLi.insertAdjacentHTML)) 
                    {
                        newLi.insertAdjacentHTML("afterbegin", descripcion);
                    }
                    else 
                    {
                        insertElementInNode(newLi, descripcion);
                    }
                    setAttributes(newImg, {"src": srcImg, "alt": altImg, "width": "1000"});
                    newLi.appendChild(htmlBr);
                    newLi.appendChild(newImg);
                }
            }
        });

        /*funciones*/
        function methodValidator (element) 
        {
            var response = false;
            if (element) {
                response = true;
            }
            return response;
        }
        function insertElementInNode (element, stringContent)
        {
            var range = document.createRange();
            var frag = range.createContextualFragment(stringContent);
            element.appendChild(frag, element);
        }
        function setAttributes (element, attrs)
        {
            for (var key in attrs) {
                element.setAttribute(key, attrs[key]);
            }
        }
    </script>
</body>
</html>